1. 各种类型请求的处理入口：BrokerController#registerProcessor

2. rocketmq高性能：
页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。

在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。

另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。

3. 基本概念
一、生产者
　　生产者发送业务系统产生的消息给broker。RocketMQ提供了多种发送方式：同步的、异步的、单向的。

1.1 生产者组
　　具有相同角色的生产者被分到一组。假如原始的生产者在事务后崩溃，broker会联系 同一生产者组中的不同生产者实例，继续提交或回滚事务。

二、消费者
　　一个消费者从broker拉取信息，并将信息返还给应用。为了我们应用的正确性，提供了两种消费者类型：

　　拉式消费者：拉式消费者从broker拉取消息，一旦一批消息被拉取，用户应用系统将发起消费过程。

　　推式消费者：推式消费者，从另一方面讲，囊括了消息的拉取、消费过程，并保持了内部的其他工作，留下了一个回调 接口给终端用户去实现，实现在消息到达时要执行的内容。

2.1 消费者组
　　具有相同角色的消费者被组在一起，称为消费者组。它是一个伟大的概念，它完成了负载均衡和容错的目标。 就消费消息而言，它是非常容易的。

一个消费组中的消费者实例必须有确定的相同的订阅topic。

三、Topic（主题）
　　Topic是一个消息的目录，在这个目录中，生产者传送消息，消费者拉取消息。Topic与生产者和消费者之间的关系非常的宽松。 明确的，一个Topic可以有0个，1个或多个生产者向它发送消息。相反的，一个生产者可以发送不同Topic的消息。 在消费者方面，一个Topic可以被0个，1个或多个消费者组订阅。相似的，一个消费者组可以订阅1个或多个Topic，只要组内的消费者实例 保持订阅的一致性。

四、Message（消息）
　　消息是被传递的信息。一个消息必须有一个Topic，它可以理解为信件上的地址。一个消息也可以有一个可选的tag，和额外的key-value对。 例如：你可以设置业务中的键到你的消息中，在broker服务中查找消息，以便在开发期间诊断问题。

五、消息队列
　　Topic被分割成一个或多个消息队列。队列分为3中角色：异步主、同步主、从。如果你不能容忍消息丢失，我们建议你部署同步主，并加一个从队列。 如果你容忍丢失，但你希望队列总是可用，你可以部署异步主和从队列。如果你想最简单，你只需要一个异步主，不需要从队列。 消息保存磁盘的方式也有两种，推荐使用的是异步保存，同步保存是昂贵的并会导致性能损失，如果你想要可靠性，我们推荐你使用同步主+从的方式。

六、Tag（标签）
　　标签，用另外一个词来说，就是子主题，为用户提供额外的灵活性。具有相同Topic的消息可以有不同的tag。

七、Broker（队列）
　　Broker是RocketMQ的一个主要组件，它接收生产者发送的消息，存储它们并准备处理消费者的拉取请求。它也存储消息相关的元数据， 包括消费组，消费成功的偏移量，主题、队列的信息。

八、名称服务
　　名称服务主要提供路由信息。生产者/消费者客户端寻找topic，并找到通信的队列列表。

九、消息的顺序
　　当DefaultMQPushConsumer被使用，你就要决定消费消息时，是顺序消费还是同时消费。

顺序消费
　　顺序消费消息的意思是 消息将按照生产者发送到队列时的顺序被消费掉。如果你被强制要求使用全局的顺序，你要确保你的topic只有一个消息队列。

如果指定顺序消费，消息被同时消费的数量就是订阅这个topic的消费组的数量。

同时消费
　　当同时消费消息时，消息同时消费的最大数量取决于消费客户端指定的线程池的大小。

消息写入时是直接入CommitLog，然后有后台线程CommitLogDispatcher，异步生成IndexFile，ConsumeQueue中的数据

10：通过nameserv，broker，client的processor中的请求类型，就知道这几个角色做哪些事情

11. rocketmq的界面项目：https://github.com/apache/rocketmq-externals

12. 配置参数解释：
clusterName：集群名字,比如 DefaultCluster
brokerName：broker分片名字，比如 broker-a，一个集群（即clusterName）下如果有多个分片，这多个分片名字不能相同，每个分片的从节点和主节点名字一样
brokerId：分片id编号，0-主 1等其他非0数字-从
brokerRole：分片角色，MASTER-主  SLAVE-从
其他待添加